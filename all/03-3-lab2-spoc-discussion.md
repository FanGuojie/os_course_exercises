# lec7:  lab2 SPOC思考题

NOTICE

* 有"w4l1"标记的题是助教要提交到学堂在线上的。
* 有"w4l1"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
* 有"hard"标记的题有一定难度，鼓励实现。
* 有"easy"标记的题很容易实现，鼓励实现。
* 有"midd"标记的题是一般水平，鼓励实现。

## 提前准备

* 完成lec7\(lab2\)的视频学习和提交对应的在线练习
* git pull ucore\_os\_lab, v9\_cpu, os\_course\_spoc\_exercises 　in github repos。这样可以在本机上完成课堂练习。
* 理解如何实现建立页表（主要自学和网上查找）

## 第七讲视频相关思考题

### 7.1 了解x86保护模式中的特权级

1. X86有几个特权级？

   答：CPU有4个特权级，通常操作系统使用0和3两个，1和2作为扩展


2. 不同特权级有什么区别？

   特权指令只能在特权级0下使用，一条指令在不同特权下能访问的数据范围不一样，一条指令字不同特权级下的行为也可能不同


3. 请说明CPL、DPL和RPL在中断响应、函数调用和指令执行时的作用。

   访问门时：从低优先级代码访问高优先级服务

   访问段时：从高优先级代码访问低优先级数据

   CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。
   RPL说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。ARPL指令改目标数据块选择子的RPL为主调程序的CPL
   DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定。
   当进程访问一个段时，需要进程特权级检查，一般要求DPL >= max {CPL, RPL}  （记法：MAX返回的值不能大于DPL就可以访问）


4. 写一个示例程序，完成4个特权级间的函数调用和数据访问时特权级控制的作用。

### 7.2 了解特权级切换过程

1. 一条指令在执行时会有哪些可能的特权级判断？

   答：

   * 当代码访问数据时，需要check当前特权级是否等于或高于要访问的数据段的DPL
   * 如果是通过段寄存器SS访问数据段，则要求CPL、RPL=DPL。
   * 如果代码设计到控制转移，则一般只允许低特权级调用高特权级代码。
   * 发生中断或异常时，需要判断当前的门描述符的特权级和目标代码的特权级。

2. 在什么情况下会出现特权级切换？

   * 当低特权级代码调用高特权级代码时
   * 中断等发生时

3. int指令在ring0和ring3的执行行为有什么不同？

   压栈内容是不同的，多了一个SS:ESP的压栈

   进行了栈切换


4. 如何利用int和iret指令完成不同特权级的切换？

   人工构造需要的栈结构，然后通过int和iret指令进行切换


5. TSS和Task Register的作用是什么？

   ​	任务状态描述符表TSS用来记录当前进程执行时所对应的寄存器的数据，这些数据主要在进程切换时发挥作用，比如，现在要由当前进程"进程A"切换到进程B，那么系统就要将此时各个寄存器的数值，保存在进程A的任务状态描述符表中，以便将来进程A再次执行时接着使用而不至于出现混乱；之后，再用进程B中TSS里面的寄存器值，来设置相应的寄存器，以此支持进程B接下来的执行。
   ​	在局部数据描述符表LDT中，记录着当前进程对应程序的代码段和数据段信息，比如代码的基地址等，这些信息将在进程程序执行时提供支持。
   ​	系统将来就是通过GDT表中挂接的TSS描述符合LDT描述符，来与当前进程建立关系的，这里将TSS和LDT挂接在全局描述符表GDT中，标志着系统从此具备操作进程1的能力

   ​	任务寄存器（TR）通过指向一个TSS，寻址了当前正在执行的任务。

   ​       任务寄存器有一个“可见部分”（也就是说，可以被指令读写的部分）和一个“不可见部分”（由处理器操作，对应着可见部分，不可以通过指令来读写）。可见部分的选择子部分选择了一个在GDT中的TSS。处理器用不可见部分来缓存TSS描述符中的基址和界限值。把基址和界限保存在一个寄存器中可以提高任务的执行性能，因为处理器不必每次都访问内存来得到当前任务TSS的这些值。

   ​        LTR指令和STR指令是用来更改和读取任务寄存器的可见部分的。两条指令都有一个操作数，一个在内存中的或在通用寄存器中的16-位选择子。

   ​       **LTR（Load task register）**加载一个选择子操作数到任务寄存器的可见部分，这个选择子必须指定一个在GDT中的TSS描述符。LTR也用TSS中的信息来加载任务寄存器的不可见部分。LTR是一条特权指令，只能当CPL是0时才能执行这条执令。LTR一般是当操作系统初始化过程执行的，用来初始化任务寄存器。以后，任务寄存器（TR）的内容由每次任务切换来改变。

   ​        **STR（Store task register）**存储任务寄存器的可见部分到一个通用寄存器或者到一个内存的字内。STR不是特权指令。

   ​	任务寄存器tr保存 16 位的段选择子、32 位基地址、16 位段界限和当前任务的 TSS属性。它引用 GDT 中的 TSS 描述符。基地址指明 TSS 的第一个字节（字节 0）的线性地址，段界限确定 TSS 的字节个数。TR寄存器包含了当前正在CPU运行的进程的TSSD（任务段描述符）选择符。也包含了两个隐藏的非编程域：TSSD的base 和limit域。通过这种方式处理器就能直接对TSS寻址，而不用从GDT中索引TSS的地址。

   ​	cpu会把当前寄存器的数据保存到当前（旧的）tr寄存器所指向的tss数据结构里，然后把新的tss数据复制到当前寄存器里。这些操作是通过cpu的硬件实现的。

   

   

 > [Task state segment](https://en.wikipedia.org/wiki/Task_state_segment)

 > Reference: [Intel® 64 and IA-32 Architectures Software Developer Manuals](http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring/lecture04?action=AttachFile&do=view&target=325462-sdm-vol-1-2abcd-3abcd.pdf) Page 2897/4684: 7.2.1 Task-State Segment (TSS)

### 7.3 了解段/页表

1. 一条指令执行时最多会出现多少次地址转换？

   2次转换，从虚拟地址到线性地址，从线性地址到物理地址

   如果考虑多级页表会多几级转换

2. 描述X86-32的MMU地址转换过程；

   ​	从逻辑地址到线性地址的映射过程：

   * 根据指令的性质来确定应该使用哪一个寄存器，例如转移指令中的地址中代码段，而取数据指令中的地址中数据段

   * 根据段寄存器的内容，找到相应的“地址段描述结构”，段描述结构都放在一个表中（GDT或LDT、TR、IDT），而表的起始地址保存着GDTR、LDTR、IDRT、TR寄存器中，这就是4个管理寄存器GDTR、LDRT、IDRT和TR的用途

   * 从地址段描述结构中找到基地址

   * 将指令发出的地址作为位移，与段描述结构中规定的段长度相比，看看是否越界

   * 根据指令的性质和段描述符中的访问权限来确定是否越权

   * 将指令中发出的地址作为位移，与基地址相加而得出线性地址

     线性地址到物理地址映射

   * 从CR3寄存器中获取页面目录的基地址

   * 以线性地址的dir位段为下标，中目录中取得相应页面表的基地址

   * 以线性地址中的page位段为下标，中所得到的页面表中获得相应的页面描述项

   * 将页面描述项中给出的页面基地址与线性地址中的offset位段的页面描述项

   * 将页面描述项中给出的页面基地址与线性地址中的offset位段相加得到物理地址

     

### 7.4 了解UCORE建立段/页表

1. 分析MMU的使能过程，尽可能详细地分析在执行进入保护械的代码“movl %eax, %cr0 ; ljmp $CODE_SEL, $0x0”时，CPU的状态和寄存器内容的变化。

   处理器能够进入到保护模式之前，需要操作系统加载和初始化软件必须在内存中设置好保护模式下使用的数据结构的基本I型梁系。这些数据结构包括：

   * 保护模式中断描述符表IDT
   * GDT
   * 任务状态段TSS
   * LDT
   * 如果使用分页机制，起码要设置一个页目录和一个页表
   * 处理器切换到保护模式下运行的代码段

   能够切换到保护模式运行之前，需要设置一下系统寄存器

   * GDTR
   * 中断描述符表基地址寄存器
   * 控制寄存器CR1~CR3

   为了实现无分页的平坦内存模型，必须设置至少一个代码段和数据段到GDT。在GDT可以使用之前，不许要使用LGDT指令将GDT表的基地址和长度加载到GDTR之中

   多端模型需要操作系统的其他段，以及用于每个应用程序的段和LDT表段

   初始化代码必须设置一个保护IDT，其中至少包含有处理器可能产生的每个异常向量对应的门描述符、

   在可以使用IDT之前，必须使用LIDT指令将IDT表基地址和长度加载到IDTR寄存器之中

   * 多任务初始化话

     如果需要使用多任务机制或者允许改变特权级，那么软件初始化代码需要设置一个TSS及相应的TSS段描述符

     在处理器切换到保护模式以后，可以用LTR指令把TSS段毛舒服的选择符加载到任务寄存器TR中。中保护模式中，软件进行第一次任务切换之前必须首先加载中TSS段的选择符，因为任务切换回吧当前任务状态复制到该TSS中

     中LTR指令执行之后，随后对任务寄存器的操作由任务切换进行

   * 切换操作的步骤

     * 使用cli指令禁止终端
     * 执行LGDT命令，加载GDT
     * 设置CR0（PE位）
     * mov cr0之后立刻跟一个远程JMP或者远程CALL指令
     * 选择性执行LLDT
     * 执行LTR指令，用初始保护模式任务的段选择符或者可写内存区域的段描述符加载任务寄存器TR
     * 进入保护模式后，段寄存器仍含有中史迪仔模式时的内容，需要进一步处理
     * LIDT
     * 开中断sti

2. 分析页表的建立过程；

   分页寄存器有控制寄存器CR0中的PG标志设置，中设置PG标志之前，必须先初始化一下数据结构和寄存器

   * 软件必须在屋里内存中建立至少一个页目录和一个页表
   * 把页目录的物理基地址加载到CR3寄存器中
   * 处理器处在保护模式下

   为了保存兼容性，设置PG标志时必须遵从以下规则

   * 设置PG标志的指令应该立即跟随一条JMP指令
   * 设置pg标志和JMP之间的代码必须来自对等映射（跳转之前的线性地址与开启分页之后的物理地址相同）的一个页面上

## 个人思考题

---

x86保护模式中权限管理无处不在，下面哪些时候要检查访问权限\(\)  \(w4l1\)

* [x] 内存寻址过程中
* [x] 代码跳转过程中
* [x] 中断处理过程中
* [ ] ALU计算过程中

请描述ucore OS建立页机制的准备工作包括哪些步骤？ \(w4l1\)

GDT的初始化，完成了段机制

物理内存的探测和空闲物理内存的管理

页表建立初始过程和设置CR0控制寄存器某位来使能页


## 小组思考题

---

（1）（spoc）请用lab1实验的基准代码（即没有修改的需要填空的源代码）来做如下实验： 执行`make qemu`，会得到一个输出结果，请给出合理的解释：为何qemu退出了？【提示】需要对qemu增加一些用于显示执行过程的参数，重点是分析其执行的指令和产生的中断或异常。 可试试"qemu-system-i386  -d help"


（2）\(spoc\)假定你已经完成了lab1的实验,接下来是对lab1的中断处理的回顾：请把你的学号对37\(十进制\)取模，得到一个数x（x的范围是-1&lt;x&lt;37），然后在你的答案的基础上，修init.c中的kern\_init函数，在大约36行处，即

```
    intr_enable();              // enable irq interrupt
```

语句之后，加入如下语句\(把x替换为你学号 mod 37得的值\)：

```
    asm volatile ("int $x");
```

然后，请回答加入这条语句后，执行`make qemu`的输出结果与你没有加入这条语句后执行`make qemu`的输出结果的差异，并解释为什么有差异或没差异？


（3）对于lab2的输出信息，请说明数字的含义

```
e820map:
  memory: 0009fc00, [00000000, 0009fbff], type = 1.
  memory: 00000400, [0009fc00, 0009ffff], type = 2.
  memory: 00010000, [000f0000, 000fffff], type = 2.
  memory: 07ee0000, [00100000, 07fdffff], type = 1.
  memory: 00020000, [07fe0000, 07ffffff], type = 2.
  memory: 00040000, [fffc0000, ffffffff], type = 2.
```

修改lab2，让其显示`type="some string"` 让人能够读懂，而不是不好理解的数字1,2  \(easy\)

* [x]
>

（4）\(spoc\)有一台只有页机制的简化80386的32bit计算机，有地址范围位0~256MB的物理内存空间（physical memory），可表示大小为256MB，范围为0xC0000000~0xD0000000的虚拟地址空间（virtual address space）,页大小（page size）为4KB，采用二级页表，一个页目录项（page directory entry ，PDE）大小为4B,一个页表项（page-table entries PTEs）大小为4B，1个页目录表大小为4KB，1个页表大小为4KB。

```
PTE格式（32 bit） :
  PFN19 ... PFN0|NOUSE9 ... NOUSE0|WRITABLE|VALID
PDE格式（32 bit） :
  PT19 ... PT0|NOUSE9 ... NOUSE0|WRITABLE|VALID

其中：
NOUSE9 ... NOUSE0为保留位，要求固定为0
WRITABLE：1表示可写，0表示只读
VLAID：1表示有效，0表示无效
```

假设ucore OS已经为此机器设置好了针对如下虚拟地址&lt;--&gt;物理地址映射的二级页表，设置了页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐），其值为0。ucore OS在物理内存空间（0x1000~0x41000）已经建立和配置好了整个二级页表（包括页目录表和页表），且页目录表的index为0x300~0x363的页目录项的\(PT19 ... PT0\)的值=\(index-0x300+1\)。  
请写出一个translation程序（可基于python、ruby、C、C++、LISP、JavaScript等），输入是一个虚拟地址和一个物理地址，能够自动计算出对应的页目录项的index值,页目录项内容的值，页表项的index值，页表项内容的值。即\(pde\_idx, pde\_ctx, pte\_idx, pte\_cxt\)

请用如下值来验证你写的程序的正确性：

```
va 0xc2265b1f, pa 0x0d8f1b1f
va 0xcc386bbc, pa 0x0414cbbc
va 0xc7ed4d57, pa 0x07311d57
va 0xca6cecc0, pa 0x0c9e9cc0
va 0xc18072e8, pa 0x007412e8
va 0xcd5f4b3a, pa 0x06ec9b3a
va 0xcc324c99, pa 0x0008ac99
va 0xc7204e52, pa 0x0b8b6e52
va 0xc3a90293, pa 0x0f1fd293
va 0xce6c3f32, pa 0x007d4f32
```

参考的输出格式为：

```
va 0xcd82c07c, pa 0x0c20907c, pde_idx 0x00000336, pde_ctx  0x00037003, pte_idx 0x0000002c, pte_ctx  0x0000c20b
```
>> 注意：上述参考输出只是表示了正确的格式，其数值并不正确。
>>
>> 
---
```python

def trans(va, pa):
    pde_idx = va >> 22
    pte_idx = (va >> 12) & 0b1111111111
    pt = pa >> 12
    pte_cxt = (pt << 12) & 0b000000000011
    pde_cxt = (pde_idx - 0x300 + 1) << 12 | 0x03
    #pde_cxt = (pt << 12) & 0b000000000011
    print ('va 0x%08x, pa 0x%08x, pde_idx 0x%08x, pde_ctx 0x%08x, pte_idx 0x%08x, pte_ctx 0x%08x' % (va, pa, pde_idx, pde_cxt, pte_idx, pte_cxt))

if __name__ == '__main__':
    trans(0xc2265b1f, 0x0d8f1b1f)
    trans(0xcc386bbc, 0x0414cbbc)
    trans(0xc7ed4d57, 0x07311d57)
    trans(0xca6cecc0, 0x0c9e9cc0)
    trans(0xc18072e8, 0x007412e8)
    trans(0xcd5f4b3a, 0x06ec9b3a)
    trans(0xcc324c99, 0x0008ac99)
    trans(0xc7204e52, 0x0b8b6e52)
    trans(0xc3a90293, 0x0f1fd293)
    trans(0xce6c3f32, 0x007d4f32)

```

(5) 尝试在内存为256字节的OP-CPU机器上，设计一个支持自映射的内存空间部局。说明其页表起始逻辑地址、一级和二级虚拟地址计算公式。

## 开放思考题

---

（1）请简要分析Intel的x64 64bit体系结构下的分页机制是如何实现的


（2）Intel8086不支持页机制，但有hacker设计过包含未做任何改动的8086CPU的分页系统。猜想一下，hacker是如何做到这一点的？提示：想想MMU的逻辑位置



## v9-cpu相关

\[challenge\]在v9-cpu上，设定物理内存为64MB。在os2.c和os4.c的基础上实现页机制管理，内核空间的映射关系： kernel\_virt\_addr=0xc00000000+phy\_addr，内核空间大小为64MB，虚拟空间范围为0xc0000000--x0xc4000000, 物理空间范围为0x00000000--x0x04000000；用户空间的映射关系：user\_virt\_addr=0x40000000+usr\_phy\_addr，用户空间可用大小为1MB，虚拟空间范围为0x40000000--0x40100000，物理空间范围为0x02000000--x0x02100000。可参考v9-cpu git repo的testing分支中的os.c和mem.h。修改代码为[os5.c](https://github.com/chyyuu/v9-cpu/blob/master/root/usr/os/os5.c)

* \(1\)在内核态可正确访问这两个空间
* \(2\)在用户态可正确访问这两个空间


在使能页机制的前一条指令和后一条指令的内存地址的访问会出现什么不同/变化？


如果在建立页表过程中，使能页机制前，如果不加上`pg_dir[0]=....`，为何v9-cpu模拟器会出现"kernel stack fault"的fatal error并推出？



* 请比较一下os在v9-cpu和x86上建立页表过程的不同之处，需要考虑硬件设计上的差异
* [x]
